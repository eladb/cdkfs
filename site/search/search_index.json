{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"awscdk-construct/","text":"AWS CDK Construct Library This projen type is used for building AWS CDK constructs using the jsii. The jsii allows you to write code once in Typescript and it will generate the Python, .net, and Java equivalents. Use this if you'd like to build and distribute CDK constructs for others to use. Class heirarchy: AwsCdkConstructLibrary -> ConstructLibrary -> JsiiProject -> TypeScriptProject -> NodeProject -> Project Table of Contents Getting Started Standard Node Module Fields Dependencies jsii Publishing Workflows Scripts Construct Catalog API Documentation Project structure Migrating existing projects Feedback Getting Started Start like all projen projects: npx projen new awscdk-construct Review the resulting .projenrc.js file and make changes as needed. The following are some specific areas you may want to set explicitly. Module Metadata These fields are your basic Node module setup: authorAddress: 'benisrae@amazon.com', authorName: 'Elad Ben-Israel', description: 'Watching your CDK apps since 2019', name: 'cdk-watchful', license: 'MIT', repository: 'https://github.com/eladb/cdk-watchful.git', keywords: ['cloudwatch', 'monitoring'] All are pretty standard setup and nothing CDK-specific at this point. The keywords automatically gets 'cdk' so you don't need to specify it. Dependencies Depending on AWS CDK modules Next are getting CDK dependencies added: cdkVersion: '1.67.0', cdkDependencies: ['@aws-cdk/aws-ec2'], cdkTestDependencies: ['@aws-cdk/assert'], cdkDependencies will add both dependencies and peerDependencies to your package.json file with a caret semver requirement (e.g. ^1.67.0 ). CDK dependencies must be both direct and peer dependencies, see this issue . You can set cdkVersionPinning to true to use a fixed version, but this means that any consumer of your library will have to use this exact CDK version. Likewise, cdkTestDependencies will add dependencies to the devDependencies . Additionally, you can add CDK dependencies using the methods: project.addCdkDependencies('aws-cdk/aws-sqs', 'aws-cdk/aws-sns'); project.addCdkTestDependencies('aws-cdk/something-else'); The @aws-cdk/assert library is already added to the cdkTestDependencies for you. Depending on other modules If your library consumes other jsii modules, you should declare them thorugh the deps or peerDeps options. deps should be used if types from the consumed module is not part of the public API of the library (the module is used as an implementation detail), while peerDeps must be used if types from the consumed module are exported as part of your library's API. You can read more here . deps: [ 'cdk-time-bomb' ] A dependabot file will be added unless dependabot is set to 'false'. jsii Publishing As this is a jsii project , it will cross-compile to other languages. You can set up any number of jsii target languages. dotnet: { dotNetNamespace: 'Acme.HelloNamespace', packageId: 'Acme.HelloPackage' }, java: { javaPackage: 'com.acme.hello', mavenArtifactId: 'hello-jsii', mavenGroupId: 'com.acme.hello' }, python: { distName: 'acme.hello-jsii', module: 'acme.hello_jsii' }, jsii-release is used for publishing, and requires uploading Github project secrets based on the repositories you wish to publish to: npm - NPM_TOKEN ( docs ) .NET - NUGET_API_KEY ( docs ) Java: MAVEN_GPG_PRIVATE_KEY , MAVEN_GPG_PRIVATE_KEY_PASSPHRASE , MAVEN_PASSWORD , MAVEN_USERNAME , MAVEN_STAGING_PROFILE_ID ( docs ) Python: TWINE_USERNAME , TWINE_PASSWORD ( docs ) For help in getting these secrets for your project, read the jsii-release . If you don't want to publish a particular package, do not include the dotnet , java , or python field. Workflows Two workflows will be created as Github Actions: The Build workflow - controlled by the buildWorkflow field. On a 'pull_request' or 'workflow_dispatch' the library will be built and checked for anti-tamper (ensure no manual changes to generated files). The Release workflow - controlled by the releaseWorkflow field. On a push to master (overridden at props.defaultReleaseBranch ) the library is built, anti-tampered, version bumped with a commit, pushed back to git, and then published to the configured artifact repositories (e.g. npm, pypi). Scripts There are a number of package scripts that are created for you. Any of them can be overwritten using the addScript* methods. script description start starts an interactive command menu projen regenerates the projen config. Run this if you edit .projenrc.js no-changes a helper script to prevent unnecessary releases. bump bumps the package version number release bumps the library's version and pushes to origin projen:upgrade upgrades the projen cli tool compile builds the library and generates docs watch compiles and then re-compiles of further changes package runs jsii-pacmak to package your library for publishing test compiles and runs automated tests test:watch watches for file changes, re-compiles and re-tests test:update update any test snapshots eslint runs eslint against all src and test .ts files compat checks for jsii compatibility. See here for more info. docgen generate documentation As you develop your library you'll likely be using the test:watch command the most. Construct Catalog Finally, a field for setting up publishing to the construct catalog : catalog: { announce: true, twitter: '@yourhandle' } These values are optional but allow the construct catalog's Twitter account to mention your handle on the tweet. Setting announce to 'false' will stop all tweets about the library. However, the library will still be indexed. API Documentation Docs will be generated from Typescript comments and saved in the API.md file. Please review this file regularly and document your constructs liberally. Project structure . |--lib/ (generated) |--src/ |--main.ts |--test/ |--main.test.ts Source .ts files should reside in the src directory. Constructs should be exported from the main.ts file. Compiled files will be put in the lib directory. Tests are in the test directory. If you need additional resources that are packaged with your library, add those to a resources directory that is besides the src directory and modify your references accordingly: const thing = require('../resources/some-resource.json') Migrating existing projects Your existing CDK constructs likely have a different file structure than what this projen project expects. Projen projects are highly opinionated. There are a few expectations of this project you should modify your existing library to conform to: All .ts files are expected to be in the src/ directory. Existing constructs should all be moved there. However, you can override this directory by setting srcdir . Compiled .js and .d.ts files will go into the lib/ directory. This directory will be removed and rebuilt each build. Do not store source .ts files in your lib/ or 'libdir'. The entrypoint file for all constructs should be src/main.ts . If your existing library is not in the main.ts file, you can add the following to export it: export * from './our-s3-bucket' Feedback If you find there is anything we missed, please submit Issues or (better yet) Pull Requests on Github.","title":"AWS CDK Construct Library"},{"location":"awscdk-construct/#aws-cdk-construct-library","text":"This projen type is used for building AWS CDK constructs using the jsii. The jsii allows you to write code once in Typescript and it will generate the Python, .net, and Java equivalents. Use this if you'd like to build and distribute CDK constructs for others to use. Class heirarchy: AwsCdkConstructLibrary -> ConstructLibrary -> JsiiProject -> TypeScriptProject -> NodeProject -> Project","title":"AWS CDK Construct Library"},{"location":"awscdk-construct/#table-of-contents","text":"Getting Started Standard Node Module Fields Dependencies jsii Publishing Workflows Scripts Construct Catalog API Documentation Project structure Migrating existing projects Feedback","title":"Table of Contents"},{"location":"awscdk-construct/#getting-started","text":"Start like all projen projects: npx projen new awscdk-construct Review the resulting .projenrc.js file and make changes as needed. The following are some specific areas you may want to set explicitly.","title":"Getting Started"},{"location":"awscdk-construct/#module-metadata","text":"These fields are your basic Node module setup: authorAddress: 'benisrae@amazon.com', authorName: 'Elad Ben-Israel', description: 'Watching your CDK apps since 2019', name: 'cdk-watchful', license: 'MIT', repository: 'https://github.com/eladb/cdk-watchful.git', keywords: ['cloudwatch', 'monitoring'] All are pretty standard setup and nothing CDK-specific at this point. The keywords automatically gets 'cdk' so you don't need to specify it.","title":"Module Metadata"},{"location":"awscdk-construct/#dependencies","text":"","title":"Dependencies"},{"location":"awscdk-construct/#depending-on-aws-cdk-modules","text":"Next are getting CDK dependencies added: cdkVersion: '1.67.0', cdkDependencies: ['@aws-cdk/aws-ec2'], cdkTestDependencies: ['@aws-cdk/assert'], cdkDependencies will add both dependencies and peerDependencies to your package.json file with a caret semver requirement (e.g. ^1.67.0 ). CDK dependencies must be both direct and peer dependencies, see this issue . You can set cdkVersionPinning to true to use a fixed version, but this means that any consumer of your library will have to use this exact CDK version. Likewise, cdkTestDependencies will add dependencies to the devDependencies . Additionally, you can add CDK dependencies using the methods: project.addCdkDependencies('aws-cdk/aws-sqs', 'aws-cdk/aws-sns'); project.addCdkTestDependencies('aws-cdk/something-else'); The @aws-cdk/assert library is already added to the cdkTestDependencies for you.","title":"Depending on AWS CDK modules"},{"location":"awscdk-construct/#depending-on-other-modules","text":"If your library consumes other jsii modules, you should declare them thorugh the deps or peerDeps options. deps should be used if types from the consumed module is not part of the public API of the library (the module is used as an implementation detail), while peerDeps must be used if types from the consumed module are exported as part of your library's API. You can read more here . deps: [ 'cdk-time-bomb' ] A dependabot file will be added unless dependabot is set to 'false'.","title":"Depending on other modules"},{"location":"awscdk-construct/#jsii-publishing","text":"As this is a jsii project , it will cross-compile to other languages. You can set up any number of jsii target languages. dotnet: { dotNetNamespace: 'Acme.HelloNamespace', packageId: 'Acme.HelloPackage' }, java: { javaPackage: 'com.acme.hello', mavenArtifactId: 'hello-jsii', mavenGroupId: 'com.acme.hello' }, python: { distName: 'acme.hello-jsii', module: 'acme.hello_jsii' }, jsii-release is used for publishing, and requires uploading Github project secrets based on the repositories you wish to publish to: npm - NPM_TOKEN ( docs ) .NET - NUGET_API_KEY ( docs ) Java: MAVEN_GPG_PRIVATE_KEY , MAVEN_GPG_PRIVATE_KEY_PASSPHRASE , MAVEN_PASSWORD , MAVEN_USERNAME , MAVEN_STAGING_PROFILE_ID ( docs ) Python: TWINE_USERNAME , TWINE_PASSWORD ( docs ) For help in getting these secrets for your project, read the jsii-release . If you don't want to publish a particular package, do not include the dotnet , java , or python field.","title":"jsii Publishing"},{"location":"awscdk-construct/#workflows","text":"Two workflows will be created as Github Actions: The Build workflow - controlled by the buildWorkflow field. On a 'pull_request' or 'workflow_dispatch' the library will be built and checked for anti-tamper (ensure no manual changes to generated files). The Release workflow - controlled by the releaseWorkflow field. On a push to master (overridden at props.defaultReleaseBranch ) the library is built, anti-tampered, version bumped with a commit, pushed back to git, and then published to the configured artifact repositories (e.g. npm, pypi).","title":"Workflows"},{"location":"awscdk-construct/#scripts","text":"There are a number of package scripts that are created for you. Any of them can be overwritten using the addScript* methods. script description start starts an interactive command menu projen regenerates the projen config. Run this if you edit .projenrc.js no-changes a helper script to prevent unnecessary releases. bump bumps the package version number release bumps the library's version and pushes to origin projen:upgrade upgrades the projen cli tool compile builds the library and generates docs watch compiles and then re-compiles of further changes package runs jsii-pacmak to package your library for publishing test compiles and runs automated tests test:watch watches for file changes, re-compiles and re-tests test:update update any test snapshots eslint runs eslint against all src and test .ts files compat checks for jsii compatibility. See here for more info. docgen generate documentation As you develop your library you'll likely be using the test:watch command the most.","title":"Scripts"},{"location":"awscdk-construct/#construct-catalog","text":"Finally, a field for setting up publishing to the construct catalog : catalog: { announce: true, twitter: '@yourhandle' } These values are optional but allow the construct catalog's Twitter account to mention your handle on the tweet. Setting announce to 'false' will stop all tweets about the library. However, the library will still be indexed.","title":"Construct Catalog"},{"location":"awscdk-construct/#api-documentation","text":"Docs will be generated from Typescript comments and saved in the API.md file. Please review this file regularly and document your constructs liberally.","title":"API Documentation"},{"location":"awscdk-construct/#project-structure","text":". |--lib/ (generated) |--src/ |--main.ts |--test/ |--main.test.ts Source .ts files should reside in the src directory. Constructs should be exported from the main.ts file. Compiled files will be put in the lib directory. Tests are in the test directory. If you need additional resources that are packaged with your library, add those to a resources directory that is besides the src directory and modify your references accordingly: const thing = require('../resources/some-resource.json')","title":"Project structure"},{"location":"awscdk-construct/#migrating-existing-projects","text":"Your existing CDK constructs likely have a different file structure than what this projen project expects. Projen projects are highly opinionated. There are a few expectations of this project you should modify your existing library to conform to: All .ts files are expected to be in the src/ directory. Existing constructs should all be moved there. However, you can override this directory by setting srcdir . Compiled .js and .d.ts files will go into the lib/ directory. This directory will be removed and rebuilt each build. Do not store source .ts files in your lib/ or 'libdir'. The entrypoint file for all constructs should be src/main.ts . If your existing library is not in the main.ts file, you can add the following to export it: export * from './our-s3-bucket'","title":"Migrating existing projects"},{"location":"awscdk-construct/#feedback","text":"If you find there is anything we missed, please submit Issues or (better yet) Pull Requests on Github.","title":"Feedback"},{"location":"node/","text":"Node.js Projects This topic describes all the features of NodeProject projects and their derivatives. Development Workflow TODO Dependencies TODO Pull Request Builds (CI) TODO Releases (CI/CD) TODO Rebuild Bot Installs a GitHub workflow which is triggered by adding a comment on a pull request which reads @projen rebuild . The workflow will check out the PR branch and build it (with no anti-tamper checks), and then it will push the changes back to the PR branch. This is particularly useful in order to update test snapshots and other generated files such as API.md . Options: To disable, set rebuildBot to false . You can specify a different trigger comment through rebuildBotComment .","title":"Node.js Projects"},{"location":"node/#nodejs-projects","text":"This topic describes all the features of NodeProject projects and their derivatives.","title":"Node.js Projects"},{"location":"node/#development-workflow","text":"TODO","title":"Development Workflow"},{"location":"node/#dependencies","text":"TODO","title":"Dependencies"},{"location":"node/#pull-request-builds-ci","text":"TODO","title":"Pull Request Builds (CI)"},{"location":"node/#releases-cicd","text":"TODO","title":"Releases (CI/CD)"},{"location":"node/#rebuild-bot","text":"Installs a GitHub workflow which is triggered by adding a comment on a pull request which reads @projen rebuild . The workflow will check out the PR branch and build it (with no anti-tamper checks), and then it will push the changes back to the PR branch. This is particularly useful in order to update test snapshots and other generated files such as API.md . Options: To disable, set rebuildBot to false . You can specify a different trigger comment through rebuildBotComment .","title":"Rebuild Bot"},{"location":"tasks/","text":"Tasks Tasks are a project-level feature to define a project command system backed by shell scripts. Tasks are used to implement development workflows and are accessible through the projen CLI as subcommands. The following example defines a task named \"hello\" which executes the shell command echo hello, world! : const hello = project.addTask('hello'); hello.exec('echo hello, world!'); Run pj and the task will be available in the CLI: $ projen hello \ud83e\udd16 hello | echo hello, world! hello, world! You can also define some metadata and the first exec step declaratively: const projen = require('projen'); const hello = project.addTask('hello', { description: 'say hello', category: projen.tasks.TaskCategory.TEST, exec: 'echo hello, world!' }); Steps Tasks can include any number of steps : hello.exec('echo step number 2'); // a name can be added to a step if desired hello.exec('echo foo bar', { name: 'print the text \"foo bar\"' }); The --inspect option can be used to display the contents of a task: $ projen hello --inspect echo hello, world! echo step number 2 echo foo bar If a step fails, the task will fail and all subsequent steps will not be executed. You can also add steps to the beginning of a task: const hello = project.addTask('hello'); hello.exec('echo hello'); hello.prepend('echo world'); Then: $ projen hello 2> /dev/null world hello Subtasks Tasks can also spawn sub-tasks as a step: const world = project.addTask('world'); world.exec('echo world!'); const hello = project.addTask('hello'); hello.exec('echo hello'); hello.spawn(world); The output will be: $ projen hello \ud83e\udd16 hello | echo hello hello \ud83e\udd16 hello \u00bb world | echo world! world! $ projen hello --inspect echo hello world: echo world! Environment Environment variables can be defined at the project level (for all tasks) or the task level: project.tasks.addEnvironment('FOO', 'hello'); const hello = project.addTask('hello'); hello.env('BAR', 'world'); hello.exec('echo $FOO, $BAR!'); Then: $ projen hello \ud83e\udd16 hello | echo $FOO, $BAR! hello, world! You can also evaluate environment variable values from a shell command: const hello = project.addTask('hello'); hello.env('TIME', '$(date)'); hello.exec('echo current time is $TIME'); Then: $ projen hello \ud83e\udd16 hello | echo current time is $TIME current time is Tue Dec 1 09:32:33 IST 2020 Conditions The condition option includes a command that determines if the task is executed. If the command exits successfully (with a zero exit code), steps will be executed. Otherwise, the task will be skipped (successfully). const hello = project.addTask('hello', { condition: '[ -n \"$CI\" ]', // only execute if the CI environment variable is defined exec: 'echo running in a CI environment' }); Then: $ projen hello \ud83e\udd16 hello | condition: [ -n \"$CI\" ] \ud83e\udd16 hello | condition exited with non-zero - skipping $ CI=1 projen hello \ud83e\udd16 hello | condition: [ -n \"$CI\" ] \ud83e\udd16 hello | echo running in a CI environment running in a CI environment Tasks as npm scripts By default, npm scripts in NodeProject s (or derivatives) are implemented by delegating the command to the projen CLI: { \"scripts\": { \"compile\": \"npx projen compile\" } } This means that when yarn compile or npm run compile are executed, the projen CLI will be invoked and the task will be executed. You can set npmTaskExecution: NpmTaskExecution.SHELL when the project is defined to tell projen to render the task command directly as an npm script, bypassing the projen CLI: const project = new NodeProject({ // ... npmTaskExecution: NpmTaskExecution.SHELL, }); And then, this is how package.json will look like: { \"scripts\": { \"compile\": \"tsc\" } }","title":"Tasks"},{"location":"tasks/#tasks","text":"Tasks are a project-level feature to define a project command system backed by shell scripts. Tasks are used to implement development workflows and are accessible through the projen CLI as subcommands. The following example defines a task named \"hello\" which executes the shell command echo hello, world! : const hello = project.addTask('hello'); hello.exec('echo hello, world!'); Run pj and the task will be available in the CLI: $ projen hello \ud83e\udd16 hello | echo hello, world! hello, world! You can also define some metadata and the first exec step declaratively: const projen = require('projen'); const hello = project.addTask('hello', { description: 'say hello', category: projen.tasks.TaskCategory.TEST, exec: 'echo hello, world!' });","title":"Tasks"},{"location":"tasks/#steps","text":"Tasks can include any number of steps : hello.exec('echo step number 2'); // a name can be added to a step if desired hello.exec('echo foo bar', { name: 'print the text \"foo bar\"' }); The --inspect option can be used to display the contents of a task: $ projen hello --inspect echo hello, world! echo step number 2 echo foo bar If a step fails, the task will fail and all subsequent steps will not be executed. You can also add steps to the beginning of a task: const hello = project.addTask('hello'); hello.exec('echo hello'); hello.prepend('echo world'); Then: $ projen hello 2> /dev/null world hello","title":"Steps"},{"location":"tasks/#subtasks","text":"Tasks can also spawn sub-tasks as a step: const world = project.addTask('world'); world.exec('echo world!'); const hello = project.addTask('hello'); hello.exec('echo hello'); hello.spawn(world); The output will be: $ projen hello \ud83e\udd16 hello | echo hello hello \ud83e\udd16 hello \u00bb world | echo world! world! $ projen hello --inspect echo hello world: echo world!","title":"Subtasks"},{"location":"tasks/#environment","text":"Environment variables can be defined at the project level (for all tasks) or the task level: project.tasks.addEnvironment('FOO', 'hello'); const hello = project.addTask('hello'); hello.env('BAR', 'world'); hello.exec('echo $FOO, $BAR!'); Then: $ projen hello \ud83e\udd16 hello | echo $FOO, $BAR! hello, world! You can also evaluate environment variable values from a shell command: const hello = project.addTask('hello'); hello.env('TIME', '$(date)'); hello.exec('echo current time is $TIME'); Then: $ projen hello \ud83e\udd16 hello | echo current time is $TIME current time is Tue Dec 1 09:32:33 IST 2020","title":"Environment"},{"location":"tasks/#conditions","text":"The condition option includes a command that determines if the task is executed. If the command exits successfully (with a zero exit code), steps will be executed. Otherwise, the task will be skipped (successfully). const hello = project.addTask('hello', { condition: '[ -n \"$CI\" ]', // only execute if the CI environment variable is defined exec: 'echo running in a CI environment' }); Then: $ projen hello \ud83e\udd16 hello | condition: [ -n \"$CI\" ] \ud83e\udd16 hello | condition exited with non-zero - skipping $ CI=1 projen hello \ud83e\udd16 hello | condition: [ -n \"$CI\" ] \ud83e\udd16 hello | echo running in a CI environment running in a CI environment","title":"Conditions"},{"location":"tasks/#tasks-as-npm-scripts","text":"By default, npm scripts in NodeProject s (or derivatives) are implemented by delegating the command to the projen CLI: { \"scripts\": { \"compile\": \"npx projen compile\" } } This means that when yarn compile or npm run compile are executed, the projen CLI will be invoked and the task will be executed. You can set npmTaskExecution: NpmTaskExecution.SHELL when the project is defined to tell projen to render the task command directly as an npm script, bypassing the projen CLI: const project = new NodeProject({ // ... npmTaskExecution: NpmTaskExecution.SHELL, }); And then, this is how package.json will look like: { \"scripts\": { \"compile\": \"tsc\" } }","title":"Tasks as npm scripts"}]}