import * as cp from 'child_process';
import * as os from 'os';
import * as path from 'path';
import * as fs from 'fs-extra';
import { glob } from 'glob';
import { Project } from '../';
import { GitHubProject, GitHubProjectOptions } from '../github';
import * as logging from '../logging';
import { Task } from '../task';
import { exec } from '../util';

const PROJEN_CLI = require.resolve('../../lib/cli/index.js');

logging.disable(); // no logging during tests

export class TestProject extends GitHubProject {
  constructor(options: Omit<GitHubProjectOptions, 'name'> = {}) {
    super({
      name: 'my-project',
      clobber: false,
      ...options,
    });
  }

  // override runTaskCommand in tests since the default includes the version
  // number and that will break regresion tests.
  public runTaskCommand(task: Task) {
    return `projen ${task.name}`;
  }

  postSynthesize() {
    fs.writeFileSync(path.join(this.outdir, '.postsynth'), '# postsynth');
  }
}

export function execProjenCLI(workdir: string, args: string[] = []) {
  const command = [
    process.execPath,
    PROJEN_CLI,
    ...args,
  ];

  return exec(command.map(x => `"${x}"`).join(' '), { cwd: workdir });
}

export interface SynthOutput {
  [filePath: string]: any;
}

const autoRemove = new Set<string>();

// Hook to automatically remove temporary directories without needing each
// place to actually handle this specifically.
afterAll((done) => {
  // Array.from used to get a copy, so we can safely remove from the set
  for (const dir of Array.from(autoRemove)) {
    try {
      // Note - fs-extra.removeSync is idempotent, so we're safe if the
      // directory has already been cleaned up before we get there!
      fs.removeSync(dir);
    } catch (e) {
      done.fail(e);
    }
    autoRemove.delete(dir);
  }
  done();
});

export function mkdtemp() {
  const tmpdir = fs.mkdtempSync(path.join(os.tmpdir(), 'projen-test-'));
  autoRemove.add(tmpdir);
  return tmpdir;
}

/**
 * Creates a snapshot of the files generated by a project. Ignores any non-text
 * files so that the snapshots are human readable.
 */
export function synthSnapshot(project: Project): any {
  // defensive: verify that "outdir" is actually in a temporary directory
  if (!path.resolve(project.outdir).startsWith(os.tmpdir()) && !project.outdir.includes('project-temp-dir')) {
    throw new Error('Trying to capture a snapshot of a project outside of tmpdir, which implies this test might corrupt an existing project');
  }

  const synthed = Symbol.for('synthed');
  if (synthed in project) {
    throw new Error('duplicate synth()');
  }

  (project as any)[synthed] = true;

  const ENV_PROJEN_DISABLE_POST = process.env.PROJEN_DISABLE_POST;
  try {
    process.env.PROJEN_DISABLE_POST = 'true';
    project.synth();
    const ignoreExts = ['png', 'ico'];
    return directorySnapshot(project.outdir, { excludeGlobs: ignoreExts.map(ext => `**/*.${ext}`) });
  } finally {
    fs.removeSync(project.outdir);

    // values assigned to process.env.XYZ are automatically converted to strings
    if (ENV_PROJEN_DISABLE_POST === undefined) {
      delete process.env.PROJEN_DISABLE_POST;
    } else {
      process.env.PROJEN_DISABLE_POST = ENV_PROJEN_DISABLE_POST;
    }
  }
}

export function synthSnapshotWithPost(project: Project) {
  try {
    project.synth();
    return directorySnapshot(project.outdir);
  } finally {
    fs.removeSync(project.outdir);
  }
}

export interface DirectorySnapshotOptions {
  /**
   * Globs of files to exclude.
   * @default [] include all files
   */
  readonly excludeGlobs?: string[];
}

export function directorySnapshot(root: string, options: DirectorySnapshotOptions = {}) {
  const output: SynthOutput = {};

  const files = glob.sync('**', {
    ignore: ['.git/**', ...(options.excludeGlobs ?? [])],
    cwd: root,
    nodir: true,
    dot: true,
  }); // returns relative file paths with POSIX separators

  for (const file of files) {
    const filePath = path.join(root, file);

    let content;
    if (path.extname(filePath) === '.json') {
      content = fs.readJsonSync(filePath);
    } else {
      content = fs.readFileSync(filePath, 'utf-8');
    }

    output[file] = content;
  }

  return output;
}

export function withProjectDir(code: (workdir: string) => void, options: { git?: boolean; chdir?: boolean } = {}) {
  const origDir = process.cwd();
  const outdir = mkdtemp();
  try {
    // create project under "my-project" so that basedir is deterministic
    const projectdir = path.join(outdir, 'my-project');
    fs.mkdirSync(projectdir);

    const shell = (command: string) => cp.execSync(command, { cwd: projectdir });
    if (options.git ?? true) {
      shell('git init');
      shell('git remote add origin git@boom.com:foo/bar.git');
      shell('git config user.name "My User Name"');
      shell('git config user.email "my@user.email.com"');
    } else if (process.env.CI) {
      // if "git" is set to "false", we still want to make sure global user is defined
      // (relevant in CI context)
      shell('git config user.name || git config --global user.name "My User Name"');
      shell('git config user.email || git config --global user.email "my@user.email.com"');
    }

    if (options.chdir ?? false) {
      process.chdir(projectdir);
    }

    code(projectdir);
  } finally {
    process.chdir(origDir);
    fs.removeSync(outdir);
  }
}

/**
 * Removes any non-deterministic aspects from the synthesized output.
 * @param dir The output directory.
 */
export function sanitizeOutput(dir: string) {
  const filepath = path.join(dir, 'package.json');
  const pkg = fs.readJsonSync(filepath);
  const prev = pkg.devDependencies.projen;
  if (!prev) {
    throw new Error(`expecting "${filepath}" to include a devDependency on "projen"`);
  }

  // replace the current projen version with 999.999.999 for deterministic output.
  // this will preserve any semantic version requirements (e.g. "^", "~", etc).
  pkg.devDependencies.projen = prev.replace(/\d+\.\d+\.\d+/, '999.999.999');
  fs.writeJsonSync(filepath, pkg);

  // we will also patch deps.json so that all projen deps will be set to 999.999.999
  const depsPath = path.join(dir, '.projen', 'deps.json');
  const deps = fs.readJsonSync(depsPath);
  for (const dep of deps.dependencies) {
    if (dep.name === 'projen' && dep.version) {
      dep.version = dep.version.replace(/\d+\.\d+\.\d+/, '999.999.999');
    }
  }
  fs.chmodSync(depsPath, '777');
  fs.writeJsonSync(depsPath, deps);
}
